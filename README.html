# Learn lua in 15 minutes
Awesome tutorial from http://tylerneylon.com/a/learn-lua/
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #aaaaaa; font-style: italic">-- Two dashes start a one-line comment.</span>

<span style="color: #aaaaaa; font-style: italic">--[[</span>
<span style="color: #aaaaaa; font-style: italic">     Adding two [&#39;s and ]&#39;s makes it a</span>
<span style="color: #aaaaaa; font-style: italic">     multi-line comment.</span>
<span style="color: #aaaaaa; font-style: italic">--]]</span>

<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 1. Variables and flow control.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

num = <span style="color: #009999">42</span>  <span style="color: #aaaaaa; font-style: italic">-- All numbers are doubles.</span>
<span style="color: #aaaaaa; font-style: italic">-- Don&#39;t freak out, 64-bit doubles have 52 bits for</span>
<span style="color: #aaaaaa; font-style: italic">-- storing exact int values; machine precision is</span>
<span style="color: #aaaaaa; font-style: italic">-- not a problem for ints that need &lt; 52 bits.</span>

s = <span style="color: #aa5500">&#39;walternate&#39;</span>  <span style="color: #aaaaaa; font-style: italic">-- Immutable strings like Python.</span>
t = <span style="color: #aa5500">&quot;double-quotes are also fine&quot;</span>
u = <span style="color: #aa5500">[[ Double brackets</span>
<span style="color: #aa5500">       start and end</span>
<span style="color: #aa5500">       multi-line strings.]]</span>
t = <span style="color: #0000aa">nil</span>  <span style="color: #aaaaaa; font-style: italic">-- Undefines t; Lua has garbage collection.</span>

<span style="color: #aaaaaa; font-style: italic">-- Blocks are denoted with keywords like do/end:</span>
<span style="color: #0000aa">while</span> num &lt; <span style="color: #009999">50</span> <span style="color: #0000aa">do</span>
  num = num + <span style="color: #009999">1</span>  <span style="color: #aaaaaa; font-style: italic">-- No ++ or += type operators.</span>
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- If clauses:</span>
<span style="color: #0000aa">if</span> num &gt; <span style="color: #009999">40</span> <span style="color: #0000aa">then</span>
  <span style="color: #00aaaa">print</span>(<span style="color: #aa5500">&#39;over 40&#39;</span>)
<span style="color: #0000aa">elseif</span> s ~= <span style="color: #aa5500">&#39;walternate&#39;</span> <span style="color: #0000aa">then</span>  <span style="color: #aaaaaa; font-style: italic">-- ~= is not equals.</span>
  <span style="color: #aaaaaa; font-style: italic">-- Equality check is == like Python; ok for strs.</span>
  <span style="color: #00aaaa">io.write</span>(<span style="color: #aa5500">&#39;not over 40\n&#39;</span>)  <span style="color: #aaaaaa; font-style: italic">-- Defaults to stdout.</span>
<span style="color: #0000aa">else</span>
  <span style="color: #aaaaaa; font-style: italic">-- Variables are global by default.</span>
  thisIsGlobal = <span style="color: #009999">5</span>  <span style="color: #aaaaaa; font-style: italic">-- Camel case is common.</span>

  <span style="color: #aaaaaa; font-style: italic">-- How to make a variable local:</span>
  <span style="color: #0000aa">local</span> line = <span style="color: #00aaaa">io.read</span>()  <span style="color: #aaaaaa; font-style: italic">-- Reads next stdin line.</span>

  <span style="color: #aaaaaa; font-style: italic">-- String concatenation uses the .. operator:</span>
  <span style="color: #00aaaa">print</span>(<span style="color: #aa5500">&#39;Winter is coming, &#39;</span> .. line)
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- Undefined variables return nil.</span>
<span style="color: #aaaaaa; font-style: italic">-- This is not an error:</span>
foo = anUnknownVariable  <span style="color: #aaaaaa; font-style: italic">-- Now foo = nil.</span>

aBoolValue = <span style="color: #0000aa">false</span>

<span style="color: #aaaaaa; font-style: italic">-- Only nil and false are falsy; 0 and &#39;&#39; are true!</span>
<span style="color: #0000aa">if</span> <span style="color: #0000aa">not</span> aBoolValue <span style="color: #0000aa">then</span> <span style="color: #00aaaa">print</span>(<span style="color: #aa5500">&#39;twas false&#39;</span>) <span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- &#39;or&#39; and &#39;and&#39; are short-circuited.</span>
<span style="color: #aaaaaa; font-style: italic">-- This is similar to the a?b:c operator in C/js:</span>
ans = aBoolValue <span style="color: #0000aa">and</span> <span style="color: #aa5500">&#39;yes&#39;</span> <span style="color: #0000aa">or</span> <span style="color: #aa5500">&#39;no&#39;</span>  <span style="color: #aaaaaa; font-style: italic">--&gt; &#39;no&#39;</span>

karlSum = <span style="color: #009999">0</span>
<span style="color: #0000aa">for</span> i = <span style="color: #009999">1</span>, <span style="color: #009999">100</span> <span style="color: #0000aa">do</span>  <span style="color: #aaaaaa; font-style: italic">-- The range includes both ends.</span>
  karlSum = karlSum + i
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- Use &quot;100, 1, -1&quot; as the range to count down:</span>
fredSum = <span style="color: #009999">0</span>
<span style="color: #0000aa">for</span> j = <span style="color: #009999">100</span>, <span style="color: #009999">1</span>, -<span style="color: #009999">1</span> <span style="color: #0000aa">do</span> fredSum = fredSum + j <span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- In general, the range is begin, end[, step].</span>

<span style="color: #aaaaaa; font-style: italic">-- Another loop construct:</span>
<span style="color: #0000aa">repeat</span>
  <span style="color: #00aaaa">print</span>(<span style="color: #aa5500">&#39;the way of the future&#39;</span>)
  num = num - <span style="color: #009999">1</span>
<span style="color: #0000aa">until</span> num == <span style="color: #009999">0</span>


<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 2. Functions.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

<span style="color: #0000aa">function</span> <span style="color: #00aa00">fib</span>(n)
  <span style="color: #0000aa">if</span> n &lt; <span style="color: #009999">2</span> <span style="color: #0000aa">then</span> <span style="color: #0000aa">return</span> <span style="color: #009999">1</span> <span style="color: #0000aa">end</span>
  <span style="color: #0000aa">return</span> fib(n - <span style="color: #009999">2</span>) + fib(n - <span style="color: #009999">1</span>)
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- Closures and anonymous functions are ok:</span>
<span style="color: #0000aa">function</span> <span style="color: #00aa00">adder</span>(x)
  <span style="color: #aaaaaa; font-style: italic">-- The returned function is created when adder is</span>
  <span style="color: #aaaaaa; font-style: italic">-- called, and remembers the value of x:</span>
  <span style="color: #0000aa">return</span> <span style="color: #0000aa">function</span> (y) <span style="color: #0000aa">return</span> x + y <span style="color: #0000aa">end</span>
<span style="color: #0000aa">end</span>
a1 = adder(<span style="color: #009999">9</span>)
a2 = adder(<span style="color: #009999">36</span>)
<span style="color: #00aaaa">print</span>(a1(<span style="color: #009999">16</span>))  <span style="color: #aaaaaa; font-style: italic">--&gt; 25</span>
<span style="color: #00aaaa">print</span>(a2(<span style="color: #009999">64</span>))  <span style="color: #aaaaaa; font-style: italic">--&gt; 100</span>

<span style="color: #aaaaaa; font-style: italic">-- Returns, func calls, and assignments all work</span>
<span style="color: #aaaaaa; font-style: italic">-- with lists that may be mismatched in length.</span>
<span style="color: #aaaaaa; font-style: italic">-- Unmatched receivers are nil;</span>
<span style="color: #aaaaaa; font-style: italic">-- unmatched senders are discarded.</span>

x, y, z = <span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>, <span style="color: #009999">4</span>
<span style="color: #aaaaaa; font-style: italic">-- Now x = 1, y = 2, z = 3, and 4 is thrown away.</span>

<span style="color: #0000aa">function</span> <span style="color: #00aa00">bar</span>(a, b, c)
  <span style="color: #00aaaa">print</span>(a, b, c)
  <span style="color: #0000aa">return</span> <span style="color: #009999">4</span>, <span style="color: #009999">8</span>, <span style="color: #009999">15</span>, <span style="color: #009999">16</span>, <span style="color: #009999">23</span>, <span style="color: #009999">42</span>
<span style="color: #0000aa">end</span>

x, y = bar(<span style="color: #aa5500">&#39;zaphod&#39;</span>)  <span style="color: #aaaaaa; font-style: italic">--&gt; prints &quot;zaphod  nil nil&quot;</span>
<span style="color: #aaaaaa; font-style: italic">-- Now x = 4, y = 8, values 15..42 are discarded.</span>

<span style="color: #aaaaaa; font-style: italic">-- Functions are first-class, may be local/global.</span>
<span style="color: #aaaaaa; font-style: italic">-- These are the same:</span>
<span style="color: #0000aa">function</span> <span style="color: #00aa00">f</span>(x) <span style="color: #0000aa">return</span> x * x <span style="color: #0000aa">end</span>
f = <span style="color: #0000aa">function</span> (x) <span style="color: #0000aa">return</span> x * x <span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- And so are these:</span>
<span style="color: #0000aa">local</span> <span style="color: #0000aa">function</span> <span style="color: #00aa00">g</span>(x) <span style="color: #0000aa">return</span> <span style="color: #00aaaa">math.sin</span>(x) <span style="color: #0000aa">end</span>
<span style="color: #0000aa">local</span> g; g  = <span style="color: #0000aa">function</span> (x) <span style="color: #0000aa">return</span> <span style="color: #00aaaa">math.sin</span>(x) <span style="color: #0000aa">end</span>
<span style="color: #aaaaaa; font-style: italic">-- the &#39;local g&#39; decl makes g-self-references ok.</span>

<span style="color: #aaaaaa; font-style: italic">-- Trig funcs work in radians, by the way.</span>

<span style="color: #aaaaaa; font-style: italic">-- Calls with one string param don&#39;t need parens:</span>
<span style="color: #00aaaa">print</span> <span style="color: #aa5500">&#39;hello&#39;</span>  <span style="color: #aaaaaa; font-style: italic">-- Works fine.</span>


<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 3. Tables.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

<span style="color: #aaaaaa; font-style: italic">-- Tables = Lua&#39;s only compound data structure;</span>
<span style="color: #aaaaaa; font-style: italic">--          they are associative arrays.</span>
<span style="color: #aaaaaa; font-style: italic">-- Similar to php arrays or js objects, they are</span>
<span style="color: #aaaaaa; font-style: italic">-- hash-lookup dicts that can also be used as lists.</span>

<span style="color: #aaaaaa; font-style: italic">-- Using tables as dictionaries / maps:</span>

<span style="color: #aaaaaa; font-style: italic">-- Dict literals have string keys by default:</span>
t = {key1 = <span style="color: #aa5500">&#39;value1&#39;</span>, key2 = <span style="color: #0000aa">false</span>}

<span style="color: #aaaaaa; font-style: italic">-- String keys can use js-like dot notation:</span>
<span style="color: #00aaaa">print</span>(t.key1)  <span style="color: #aaaaaa; font-style: italic">-- Prints &#39;value1&#39;.</span>
t.newKey = {}  <span style="color: #aaaaaa; font-style: italic">-- Adds a new key/value pair.</span>
t.key2 = <span style="color: #0000aa">nil</span>   <span style="color: #aaaaaa; font-style: italic">-- Removes key2 from the table.</span>

<span style="color: #aaaaaa; font-style: italic">-- Literal notation for any (non-nil) value as key:</span>
u = {[<span style="color: #aa5500">&#39;@!#&#39;</span>] = <span style="color: #aa5500">&#39;qbert&#39;</span>, [{}] = <span style="color: #009999">1729</span>, [<span style="color: #009999">6.28</span>] = <span style="color: #aa5500">&#39;tau&#39;</span>}
<span style="color: #00aaaa">print</span>(u[<span style="color: #009999">6.28</span>])  <span style="color: #aaaaaa; font-style: italic">-- prints &quot;tau&quot;</span>

<span style="color: #aaaaaa; font-style: italic">-- Key matching is basically by value for numbers</span>
<span style="color: #aaaaaa; font-style: italic">-- and strings, but by identity for tables.</span>
a = u[<span style="color: #aa5500">&#39;@!#&#39;</span>]  <span style="color: #aaaaaa; font-style: italic">-- Now a = &#39;qbert&#39;.</span>
b = u[{}]     <span style="color: #aaaaaa; font-style: italic">-- We might expect 1729, but it&#39;s nil:</span>
<span style="color: #aaaaaa; font-style: italic">-- b = nil since the lookup fails. It fails</span>
<span style="color: #aaaaaa; font-style: italic">-- because the key we used is not the same object</span>
<span style="color: #aaaaaa; font-style: italic">-- as the one used to store the original value. So</span>
<span style="color: #aaaaaa; font-style: italic">-- strings &amp; numbers are more portable keys.</span>

<span style="color: #aaaaaa; font-style: italic">-- A one-table-param function call needs no parens:</span>
<span style="color: #0000aa">function</span> <span style="color: #00aa00">h</span>(x) <span style="color: #00aaaa">print</span>(x.key1) <span style="color: #0000aa">end</span>
h{key1 = <span style="color: #aa5500">&#39;Sonmi~451&#39;</span>}  <span style="color: #aaaaaa; font-style: italic">-- Prints &#39;Sonmi~451&#39;.</span>

<span style="color: #0000aa">for</span> key, val <span style="color: #0000aa">in</span> <span style="color: #00aaaa">pairs</span>(u) <span style="color: #0000aa">do</span>  <span style="color: #aaaaaa; font-style: italic">-- Table iteration.</span>
  <span style="color: #00aaaa">print</span>(key, val)
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">-- _G is a special table of all globals.</span>
<span style="color: #00aaaa">print</span>(<span style="color: #00aaaa">_G</span>[<span style="color: #aa5500">&#39;_G&#39;</span>] == <span style="color: #00aaaa">_G</span>)  <span style="color: #aaaaaa; font-style: italic">-- Prints &#39;true&#39;.</span>

<span style="color: #aaaaaa; font-style: italic">-- Using tables as lists / arrays:</span>

<span style="color: #aaaaaa; font-style: italic">-- List literals implicitly set up int keys:</span>
v = {<span style="color: #aa5500">&#39;value1&#39;</span>, <span style="color: #aa5500">&#39;value2&#39;</span>, <span style="color: #009999">1.21</span>, <span style="color: #aa5500">&#39;gigawatts&#39;</span>}
<span style="color: #0000aa">for</span> i = <span style="color: #009999">1</span>, #v <span style="color: #0000aa">do</span>  <span style="color: #aaaaaa; font-style: italic">-- #v is the size of v for lists.</span>
  <span style="color: #00aaaa">print</span>(v[i])  <span style="color: #aaaaaa; font-style: italic">-- Indices start at 1 !! SO CRAZY!</span>
<span style="color: #0000aa">end</span>
<span style="color: #aaaaaa; font-style: italic">-- A &#39;list&#39; is not a real type. v is just a table</span>
<span style="color: #aaaaaa; font-style: italic">-- with consecutive integer keys, treated as a list.</span>

<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 3.1 Metatables and metamethods.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

<span style="color: #aaaaaa; font-style: italic">-- A table can have a metatable that gives the table</span>
<span style="color: #aaaaaa; font-style: italic">-- operator-overloadish behavior. Later we&#39;ll see</span>
<span style="color: #aaaaaa; font-style: italic">-- how metatables support js-prototypey behavior.</span>

f1 = {a = <span style="color: #009999">1</span>, b = <span style="color: #009999">2</span>}  <span style="color: #aaaaaa; font-style: italic">-- Represents the fraction a/b.</span>
f2 = {a = <span style="color: #009999">2</span>, b = <span style="color: #009999">3</span>}

<span style="color: #aaaaaa; font-style: italic">-- This would fail:</span>
<span style="color: #aaaaaa; font-style: italic">-- s = f1 + f2</span>

metafraction = {}
<span style="color: #0000aa">function</span> <span style="color: #00aa00; text-decoration: underline">metafraction</span>.<span style="color: #00aa00">__add</span>(f1, f2)
  sum = {}
  sum.b = f1.b * f2.b
  sum.a = f1.a * f2.b + f2.a * f1.b
  <span style="color: #0000aa">return</span> sum
<span style="color: #0000aa">end</span>

<span style="color: #00aaaa">setmetatable</span>(f1, metafraction)
<span style="color: #00aaaa">setmetatable</span>(f2, metafraction)

s = f1 + f2  <span style="color: #aaaaaa; font-style: italic">-- call __add(f1, f2) on f1&#39;s metatable</span>

<span style="color: #aaaaaa; font-style: italic">-- f1, f2 have no key for their metatable, unlike</span>
<span style="color: #aaaaaa; font-style: italic">-- prototypes in js, so you must retrieve it as in</span>
<span style="color: #aaaaaa; font-style: italic">-- getmetatable(f1). The metatable is a normal table</span>
<span style="color: #aaaaaa; font-style: italic">-- with keys that Lua knows about, like __add.</span>

<span style="color: #aaaaaa; font-style: italic">-- But the next line fails since s has no metatable:</span>
<span style="color: #aaaaaa; font-style: italic">-- t = s + s</span>
<span style="color: #aaaaaa; font-style: italic">-- Class-like patterns given below would fix this.</span>

<span style="color: #aaaaaa; font-style: italic">-- An __index on a metatable overloads dot lookups:</span>
defaultFavs = {animal = <span style="color: #aa5500">&#39;gru&#39;</span>, food = <span style="color: #aa5500">&#39;donuts&#39;</span>}
myFavs = {food = <span style="color: #aa5500">&#39;pizza&#39;</span>}
<span style="color: #00aaaa">setmetatable</span>(myFavs, {__index = defaultFavs})
eatenBy = myFavs.animal  <span style="color: #aaaaaa; font-style: italic">-- works! thanks, metatable</span>

<span style="color: #aaaaaa; font-style: italic">-- Direct table lookups that fail will retry using</span>
<span style="color: #aaaaaa; font-style: italic">-- the metatable&#39;s __index value, and this recurses.</span>

<span style="color: #aaaaaa; font-style: italic">-- An __index value can also be a function(tbl, key)</span>
<span style="color: #aaaaaa; font-style: italic">-- for more customized lookups.</span>

<span style="color: #aaaaaa; font-style: italic">-- Values of __index,add, .. are called metamethods.</span>
<span style="color: #aaaaaa; font-style: italic">-- Full list. Here a is a table with the metamethod.</span>

<span style="color: #aaaaaa; font-style: italic">-- __add(a, b)                     for a + b</span>
<span style="color: #aaaaaa; font-style: italic">-- __sub(a, b)                     for a - b</span>
<span style="color: #aaaaaa; font-style: italic">-- __mul(a, b)                     for a * b</span>
<span style="color: #aaaaaa; font-style: italic">-- __div(a, b)                     for a / b</span>
<span style="color: #aaaaaa; font-style: italic">-- __mod(a, b)                     for a % b</span>
<span style="color: #aaaaaa; font-style: italic">-- __pow(a, b)                     for a ^ b</span>
<span style="color: #aaaaaa; font-style: italic">-- __unm(a)                        for -a</span>
<span style="color: #aaaaaa; font-style: italic">-- __concat(a, b)                  for a .. b</span>
<span style="color: #aaaaaa; font-style: italic">-- __len(a)                        for #a</span>
<span style="color: #aaaaaa; font-style: italic">-- __eq(a, b)                      for a == b</span>
<span style="color: #aaaaaa; font-style: italic">-- __lt(a, b)                      for a &lt; b</span>
<span style="color: #aaaaaa; font-style: italic">-- __le(a, b)                      for a &lt;= b</span>
<span style="color: #aaaaaa; font-style: italic">-- __index(a, b)  &lt;fn or a table&gt;  for a.b</span>
<span style="color: #aaaaaa; font-style: italic">-- __newindex(a, b, c)             for a.b = c</span>
<span style="color: #aaaaaa; font-style: italic">-- __call(a, ...)                  for a(...)</span>

<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 3.2 Class-like tables and inheritance.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

<span style="color: #aaaaaa; font-style: italic">-- Classes aren&#39;t built in; there are different ways</span>
<span style="color: #aaaaaa; font-style: italic">-- to make them using tables and metatables.</span>

<span style="color: #aaaaaa; font-style: italic">-- Explanation for this example is below it.</span>

Dog = {}                                   <span style="color: #aaaaaa; font-style: italic">-- 1.</span>

<span style="color: #0000aa">function</span> <span style="color: #00aa00">Dog</span>:new()                         <span style="color: #aaaaaa; font-style: italic">-- 2.</span>
  newObj = {sound = <span style="color: #aa5500">&#39;woof&#39;</span>}                <span style="color: #aaaaaa; font-style: italic">-- 3.</span>
  self.__index = self                      <span style="color: #aaaaaa; font-style: italic">-- 4.</span>
  <span style="color: #0000aa">return</span> <span style="color: #00aaaa">setmetatable</span>(newObj, self)        <span style="color: #aaaaaa; font-style: italic">-- 5.</span>
<span style="color: #0000aa">end</span>

<span style="color: #0000aa">function</span> <span style="color: #00aa00">Dog</span>:makeSound()                   <span style="color: #aaaaaa; font-style: italic">-- 6.</span>
  <span style="color: #00aaaa">print</span>(<span style="color: #aa5500">&#39;I say &#39;</span> .. self.sound)
<span style="color: #0000aa">end</span>

mrDog = Dog:new()                          <span style="color: #aaaaaa; font-style: italic">-- 7.</span>
mrDog:makeSound()  <span style="color: #aaaaaa; font-style: italic">-- &#39;I say woof&#39;         -- 8.</span>

<span style="color: #aaaaaa; font-style: italic">-- 1. Dog acts like a class; it&#39;s really a table.</span>
<span style="color: #aaaaaa; font-style: italic">-- 2. function tablename:fn(...) is the same as</span>
<span style="color: #aaaaaa; font-style: italic">--    function tablename.fn(self, ...)</span>
<span style="color: #aaaaaa; font-style: italic">--    The : just adds a first arg called self.</span>
<span style="color: #aaaaaa; font-style: italic">--    Read 7 &amp; 8 below for how self gets its value.</span>
<span style="color: #aaaaaa; font-style: italic">-- 3. newObj will be an instance of class Dog.</span>
<span style="color: #aaaaaa; font-style: italic">-- 4. self = the class being instantiated. Often</span>
<span style="color: #aaaaaa; font-style: italic">--    self = Dog, but inheritance can change it.</span>
<span style="color: #aaaaaa; font-style: italic">--    newObj gets self&#39;s functions when we set both</span>
<span style="color: #aaaaaa; font-style: italic">--    newObj&#39;s metatable and self&#39;s __index to self.</span>
<span style="color: #aaaaaa; font-style: italic">-- 5. Reminder: setmetatable returns its first arg.</span>
<span style="color: #aaaaaa; font-style: italic">-- 6. The : works as in 2, but this time we expect</span>
<span style="color: #aaaaaa; font-style: italic">--    self to be an instance instead of a class.</span>
<span style="color: #aaaaaa; font-style: italic">-- 7. Same as Dog.new(Dog), so self = Dog in new().</span>
<span style="color: #aaaaaa; font-style: italic">-- 8. Same as mrDog.makeSound(mrDog); self = mrDog.</span>

<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>

<span style="color: #aaaaaa; font-style: italic">-- Inheritance example:</span>

LoudDog = Dog:new()                           <span style="color: #aaaaaa; font-style: italic">-- 1.</span>

<span style="color: #0000aa">function</span> <span style="color: #00aa00">LoudDog</span>:makeSound()
  s = self.sound .. <span style="color: #aa5500">&#39; &#39;</span>                       <span style="color: #aaaaaa; font-style: italic">-- 2.</span>
  <span style="color: #00aaaa">print</span>(s .. s .. s)
<span style="color: #0000aa">end</span>

seymour = LoudDog:new()                       <span style="color: #aaaaaa; font-style: italic">-- 3.</span>
seymour:makeSound()  <span style="color: #aaaaaa; font-style: italic">-- &#39;woof woof woof&#39;      -- 4.</span>

<span style="color: #aaaaaa; font-style: italic">-- 1. LoudDog gets Dog&#39;s methods and variables.</span>
<span style="color: #aaaaaa; font-style: italic">-- 2. self has a &#39;sound&#39; key from new(), see 3.</span>
<span style="color: #aaaaaa; font-style: italic">-- 3. Same as LoudDog.new(LoudDog), and converted to</span>
<span style="color: #aaaaaa; font-style: italic">--    Dog.new(LoudDog) as LoudDog has no &#39;new&#39; key,</span>
<span style="color: #aaaaaa; font-style: italic">--    but does have __index = Dog on its metatable.</span>
<span style="color: #aaaaaa; font-style: italic">--    Result: seymour&#39;s metatable is LoudDog, and</span>
<span style="color: #aaaaaa; font-style: italic">--    LoudDog.__index = LoudDog. So seymour.key will</span>
<span style="color: #aaaaaa; font-style: italic">--    = seymour.key, LoudDog.key, Dog.key, whichever</span>
<span style="color: #aaaaaa; font-style: italic">--    table is the first with the given key.</span>
<span style="color: #aaaaaa; font-style: italic">-- 4. The &#39;makeSound&#39; key is found in LoudDog; this</span>
<span style="color: #aaaaaa; font-style: italic">--    is the same as LoudDog.makeSound(seymour).</span>

<span style="color: #aaaaaa; font-style: italic">-- If needed, a subclass&#39;s new() is like the base&#39;s:</span>
<span style="color: #0000aa">function</span> <span style="color: #00aa00">LoudDog</span>:new()
  newObj = {}
  <span style="color: #aaaaaa; font-style: italic">-- set up newObj</span>
  self.__index = self
  <span style="color: #0000aa">return</span> <span style="color: #00aaaa">setmetatable</span>(newObj, self)
<span style="color: #0000aa">end</span>

<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>
<span style="color: #aaaaaa; font-style: italic">-- 4. Modules.</span>
<span style="color: #aaaaaa; font-style: italic">----------------------------------------------------</span>


<span style="color: #aaaaaa; font-style: italic">--[[ I&#39;m commenting out this section so the rest of</span>
<span style="color: #aaaaaa; font-style: italic">--   this script remains runnable.</span>
<span style="color: #aaaaaa; font-style: italic">-- Suppose the file mod.lua looks like this:</span>
<span style="color: #aaaaaa; font-style: italic">local M = {}</span>

<span style="color: #aaaaaa; font-style: italic">local function sayMyName()</span>
<span style="color: #aaaaaa; font-style: italic">  print(&#39;Hrunkner&#39;)</span>
<span style="color: #aaaaaa; font-style: italic">end</span>

<span style="color: #aaaaaa; font-style: italic">function M.sayHello()</span>
<span style="color: #aaaaaa; font-style: italic">  print(&#39;Why hello there&#39;)</span>
<span style="color: #aaaaaa; font-style: italic">  sayMyName()</span>
<span style="color: #aaaaaa; font-style: italic">end</span>

<span style="color: #aaaaaa; font-style: italic">return M</span>

<span style="color: #aaaaaa; font-style: italic">-- Another file can use mod.lua&#39;s functionality:</span>
<span style="color: #aaaaaa; font-style: italic">local mod = require(&#39;mod&#39;)  -- Run the file mod.lua.</span>

<span style="color: #aaaaaa; font-style: italic">-- require is the standard way to include modules.</span>
<span style="color: #aaaaaa; font-style: italic">-- require acts like:     (if not cached; see below)</span>
<span style="color: #aaaaaa; font-style: italic">local mod = (function ()</span>
<span style="color: #aaaaaa; font-style: italic">  &lt;contents of mod.lua&gt;</span>
<span style="color: #aaaaaa; font-style: italic">end)()</span>
<span style="color: #aaaaaa; font-style: italic">-- It&#39;s like mod.lua is a function body, so that</span>
<span style="color: #aaaaaa; font-style: italic">-- locals inside mod.lua are invisible outside it.</span>

<span style="color: #aaaaaa; font-style: italic">-- This works because mod here = M in mod.lua:</span>
<span style="color: #aaaaaa; font-style: italic">mod.sayHello()  -- Says hello to Hrunkner.</span>

<span style="color: #aaaaaa; font-style: italic">-- This is wrong; sayMyName only exists in mod.lua:</span>
<span style="color: #aaaaaa; font-style: italic">mod.sayMyName()  -- error</span>

<span style="color: #aaaaaa; font-style: italic">-- require&#39;s return values are cached so a file is</span>
<span style="color: #aaaaaa; font-style: italic">-- run at most once, even when require&#39;d many times.</span>

<span style="color: #aaaaaa; font-style: italic">-- Suppose mod2.lua contains &quot;print(&#39;Hi!&#39;)&quot;.</span>
<span style="color: #aaaaaa; font-style: italic">local a = require(&#39;mod2&#39;)  -- Prints Hi!</span>
<span style="color: #aaaaaa; font-style: italic">local b = require(&#39;mod2&#39;)  -- Doesn&#39;t print; a=b.</span>

<span style="color: #aaaaaa; font-style: italic">-- dofile is like require without caching:</span>
<span style="color: #aaaaaa; font-style: italic">dofile(&#39;mod2&#39;)  --&gt; Hi!</span>
<span style="color: #aaaaaa; font-style: italic">dofile(&#39;mod2&#39;)  --&gt; Hi! (runs again, unlike require)</span>

<span style="color: #aaaaaa; font-style: italic">-- loadfile loads a lua file but doesn&#39;t run it yet.</span>
<span style="color: #aaaaaa; font-style: italic">f = loadfile(&#39;mod2&#39;)  -- Calling f() runs mod2.lua.</span>

<span style="color: #aaaaaa; font-style: italic">-- loadstring is loadfile for strings.</span>
<span style="color: #aaaaaa; font-style: italic">g = loadstring(&#39;print(343)&#39;)  -- Returns a function.</span>
<span style="color: #aaaaaa; font-style: italic">g()  -- Prints out 343; nothing printed before now.</span>

<span style="color: #aaaaaa; font-style: italic">--]]</span>
</pre></div>
